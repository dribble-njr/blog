import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as e,f as l}from"./app-54685237.js";const o="/blog/assets/event-loop-d1ddb030.png",a={},p=l('<h2 id="浏览器的进程模型" tabindex="-1"><a class="header-anchor" href="#浏览器的进程模型" aria-hidden="true">#</a> 浏览器的进程模型</h2><p>JavaScript 是一个单线程的脚本语言，同一时间只能做一件事情。而为了协调事件、用户交互、脚本、渲染、网络等等，每个浏览器都有一个相关联的事件循环。</p><p>事件循环的一个循环将从宏任务队列中正在处理一个任务(这个队列在 WHATWG 规范中简称为任务队列)。在这个宏任务完成之后，所有可用的微任务都将被处理，即在同一个周期内。在处理这些微任务时，它们可以排列更多的微任务，这些任务将一个接一个地运行，直到微任务队列耗尽。</p><p>一个事件循环有一些任务队列。微任务队列不是任务队列</p><p>函数调用会形成一个调用栈，当函数调用结束后，当前函数会被弹出调用栈。</p><p>在函数执行的过程中，如果有异步任务，它们会发送给 web APIs，比如 settimeout 函数，当它在栈中执行时，会发送给对应的浏览器 API，在等待相应的时间后，他就会将回调函数放入事件队列。</p><blockquote><p>JavaScript 本身是一个单线程的，但是 web APIs 相当于另一个线程。</p></blockquote><p>事件循环会总是检查调用栈是否为空，如果为空，它就会将队列最前面的任务出队，放入执行栈中调用，如果不为空，那么继续执行当前的函数调用。</p><p>异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p>简单总结一下执行的顺序：</p><ol><li>检查宏任务队列是否为空，不为空则取出一个任务执行，然后执行第 2 步；为空则判断当前执行栈是否为空，然后执行第 2 步；</li><li>检查微任务队列是否为空，不为空则取出任务执行，直到清空微任务队列，之后执行视图更新；为空则直接执行视图更新，并回到第一步。</li></ol><figure><img src="'+o+'" alt="事件循环" tabindex="0" loading="lazy"><figcaption>事件循环</figcaption></figure><p>宏任务：</p><ol><li>整个 script 中的代码</li><li>setTimeout</li><li>setInterval</li><li>I/O</li><li>UI 交互事件</li></ol><p>微任务：</p><ol><li>promise.then .catch</li><li>mutationObserver</li><li>async await</li></ol>',16),c=[p];function s(r,n){return t(),e("div",null,c)}const f=i(a,[["render",s],["__file","0017、事件循环.html.vue"]]);export{f as default};
