import{_ as e,c as i,e as a,o}from"./app-x8ymDRL-.js";const r="/blog/assets/event-loop-DdLuqX9q.png",l={};function p(n,t){return o(),i("div",null,t[0]||(t[0]=[a('<h2 id="浏览器的进程模型" tabindex="-1"><a class="header-anchor" href="#浏览器的进程模型"><span>浏览器的进程模型</span></a></h2><p>JavaScript 是一个单线程的脚本语言，同一时间只能做一件事情。而为了协调事件、用户交互、脚本、渲染、网络等等，每个浏览器都有一个相关联的事件循环。</p><p>事件循环的一个循环将从宏任务队列中正在处理一个任务(这个队列在 WHATWG 规范中简称为任务队列)。在这个宏任务完成之后，所有可用的微任务都将被处理，即在同一个周期内。在处理这些微任务时，它们可以排列更多的微任务，这些任务将一个接一个地运行，直到微任务队列耗尽。</p><p>一个事件循环有一些任务队列。微任务队列不是任务队列</p><p>函数调用会形成一个调用栈，当函数调用结束后，当前函数会被弹出调用栈。</p><p>在函数执行的过程中，如果有异步任务，它们会发送给 web APIs，比如 settimeout 函数，当它在栈中执行时，会发送给对应的浏览器 API，在等待相应的时间后，他就会将回调函数放入事件队列。</p><blockquote><p>JavaScript 本身是一个单线程的，但是 web APIs 相当于另一个线程。</p></blockquote><p>事件循环会总是检查调用栈是否为空，如果为空，它就会将队列最前面的任务出队，放入执行栈中调用，如果不为空，那么继续执行当前的函数调用。</p><p>异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，这个事件实际上会被放到对应的宏任务和微任务队列中去。</p><p>简单总结一下执行的顺序：</p><ol><li>检查宏任务队列是否为空，不为空则取出一个任务执行，然后执行第 2 步；为空则判断当前执行栈是否为空，然后执行第 2 步；</li><li>检查微任务队列是否为空，不为空则取出任务执行，直到清空微任务队列，之后执行视图更新；为空则直接执行视图更新，并回到第一步。</li></ol><figure><img src="'+r+'" alt="事件循环" tabindex="0" loading="lazy"><figcaption>事件循环</figcaption></figure><p>宏任务：</p><ol><li>整个 script 中的代码</li><li>setTimeout</li><li>setInterval</li><li>I/O</li><li>UI 交互事件</li></ol><p>微任务：</p><ol><li>promise.then .catch</li><li>mutationObserver</li><li>async await</li></ol>',16)]))}const s=e(l,[["render",p],["__file","0017、事件循环.html.vue"]]),m=JSON.parse('{"path":"/frontend/basic/javascript/0017%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html","title":"事件循环","lang":"zh-CN","frontmatter":{"title":"事件循环","date":"2022-09-13T00:00:00.000Z","category":["JavaScript"],"tag":["事件循环"],"description":"浏览器的进程模型 JavaScript 是一个单线程的脚本语言，同一时间只能做一件事情。而为了协调事件、用户交互、脚本、渲染、网络等等，每个浏览器都有一个相关联的事件循环。 事件循环的一个循环将从宏任务队列中正在处理一个任务(这个队列在 WHATWG 规范中简称为任务队列)。在这个宏任务完成之后，所有可用的微任务都将被处理，即在同一个周期内。在处理这些...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/basic/javascript/0017%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"}],["meta",{"property":"og:title","content":"事件循环"}],["meta",{"property":"og:description","content":"浏览器的进程模型 JavaScript 是一个单线程的脚本语言，同一时间只能做一件事情。而为了协调事件、用户交互、脚本、渲染、网络等等，每个浏览器都有一个相关联的事件循环。 事件循环的一个循环将从宏任务队列中正在处理一个任务(这个队列在 WHATWG 规范中简称为任务队列)。在这个宏任务完成之后，所有可用的微任务都将被处理，即在同一个周期内。在处理这些..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-06T15:43:46.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"事件循环"}],["meta",{"property":"article:published_time","content":"2022-09-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-06T15:43:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事件循环\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-09-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-06T15:43:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 浏览器的进程模型","slug":"浏览器的进程模型","link":"#浏览器的进程模型","children":[]}],"git":{"createdTime":1677733227000,"updatedTime":1730907826000,"contributors":[{"name":"Stephen-wzw","email":"wzw15292257101@163.com","commits":2},{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":2}]},"readingTime":{"minutes":2.06,"words":619},"filePathRelative":"frontend/basic/javascript/0017、事件循环.md","localizedDate":"2022年9月13日","excerpt":"","autoDesc":true}');export{s as comp,m as data};
