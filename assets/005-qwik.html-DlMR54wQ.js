import{_ as n,c as o,e as p,a as t,d as i,b as a,r as l,o as s}from"./app-Bq0FCg7h.js";const d={},c={href:"https://www.adservio.fr/post/a-brief-history-of-web-apps-why-qwik-is-innovative",target:"_blank",rel:"noopener noreferrer"},m={href:"https://www.adservio.fr/post/qwik-the-post-modern-framework",target:"_blank",rel:"noopener noreferrer"},g={href:"https://segmentfault.com/a/1190000042250628",target:"_blank",rel:"noopener noreferrer"};function h(b,e){const r=l("ExternalLinkIcon");return s(),o("div",null,[e[3]||(e[3]=p('<h2 id="web-apps-历史" tabindex="-1"><a class="header-anchor" href="#web-apps-历史"><span>Web Apps 历史</span></a></h2><p>在了解 Qwik 之前，有必要了解 Web 应用程序的历史。</p><h3 id="第一代" tabindex="-1"><a class="header-anchor" href="#第一代"><span>第一代</span></a></h3><p>第一代应用程序采用 MPA 技术，是在服务器上通过 PHP 等技术完成的。</p><p>服务器会渲染一系列包含 HTML 和 JavaScript 的文档，客户端使用 jQuery 在模板中添加交互。</p><p>这种方法的问题在于必须处理两种语言，一种在服务器端（如 PHP），另一种在客户端（JavaScript），这可能会导致在 PHP 中编写的元素与其在 JavaScript 中的行为之间产生混淆，从而导致多次编写一个功能。</p><p>这就是这种方法难以扩展的原因。</p><h3 id="第二代" tabindex="-1"><a class="header-anchor" href="#第二代"><span>第二代</span></a></h3><p>第二代应用程序就是 SPA，即 AngularJS、Angular、React、Vue.js 等现代框架，这些框架都基于 MVC 架构。</p><p>SPA 只在客户端向服务器发起请求更新状态，但是在首次加载时，浏览器会下载所有 JavaScript 代码。</p><p>SPA 在首次加载时会是一个空白页，需要很长时间才能加载，而且如果想开发大型应用程序，它不具备可扩展性。</p><figure><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd65c5da3920b_Client Rendering-min.jpg" alt="client renderin - Adservio" tabindex="0" loading="lazy"><figcaption>client renderin - Adservio</figcaption></figure><h3 id="ssr" tabindex="-1"><a class="header-anchor" href="#ssr"><span>SSR</span></a></h3><p>处于第二代和第三代的技术就是服务端渲染，比如 Next.js 或 Svelte。</p><p>在 SSR 中，仍然构建 SPA 应用程序，然而步骤略有不同：</p><ol><li><p>服务端拼接 HTML</p><p>用户请求某个页面时，服务端会拼接好一个页面的 HTML 结构返回给客户端。</p></li><li><p>客户端对 HTML 进行预渲染</p><p>HTML 结构加载显示，但是 JavaScript 代码还未加载，此时页面还不能进行交互。</p></li><li><p>进行 hydration（水合）处理</p><p>通过 JavaScript 代码的执行，动态地为当前页面上的 DOM 绑定事件。</p></li></ol><blockquote><p>HTML 相当于一个干货海参，JavaScript 代码理解为水，hydration 过程就是用水把海参泡发，即达到页面可正常交互的状态。</p></blockquote><p>SSR 确实将首屏加载速度变快，但仍有一些缺点：</p><ol><li>在水合之前，此时页面仍然不可交互，所以 tti（页面可交互时间）并没有太多优化。</li><li>下载的 JavaScript 代码仍然是比较全量的代码。</li><li>比较耗费服务器资源，维护成本也较高。</li></ol><figure><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd612ada3920c_Server Rendering-min (1).jpg" alt="server renderin - Adservio " tabindex="0" loading="lazy"><figcaption>server renderin - Adservio </figcaption></figure><p>为了减少加载 JavaScript 代码所需的时间，Astro 框架出现了。</p><p>Astro 有一个名为「部分水合」的概念，因此在页面可见之前，它不会对页面进行水合。</p><p>例如，如果联系表单位于页面底部，而我们位于页面顶部，那么联系表单将不可见，这样就不需要加载表单所需的 JavaScript。</p><p>只有当页面向下滚动到有联系表单的部分时，才会进行水合，将表单中的组件与所需的 JavaScript 水合。</p><h2 id="qwik-介绍" tabindex="-1"><a class="header-anchor" href="#qwik-介绍"><span>Qwik 介绍</span></a></h2><p>Qwik 可以理解为一个语法接近 React 的前端 SSR 框架，但是相比于 Astro，它的优化更加彻底：<strong>「0 水合」和「0 JavaScript」</strong>。</p><p>例如，如果我们在页面底部有一个联系表单，Angular、React 或 Vue 会在首次加载时加载所需的 JavaScript，Astro 会在我们向下滚动时加载，而 Qwik 只有在点击表单的发送按钮时才会加载，它不是在页面出现表单时加载 JavaScript，<strong>而是在与表单交互时加载</strong>。</p><p>Qwik 的核心理念：to do it faster by doing nothing。</p><h3 id="resumability" tabindex="-1"><a class="header-anchor" href="#resumability"><span>Resumability</span></a></h3><p>现代的框架都在尝试优化水合作用，Qwik 的独特之处在于 <strong>可恢复性</strong> (no eager JS execution and no hydration)。</p><figure><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd6233ba391e2_Hydration - Ready-min.jpg" alt="resumability in qwik framework" tabindex="0" loading="lazy"><figcaption>resumability in qwik framework</figcaption></figure><p>如果有一个庞大的应用程序，那么加载水合将会耗费大量时间，即使使用部分水合技术，也会面临挑战。而使用可恢复性的 Qwik 技术，只加载 HTML，则不会耗费大量时间。</p><h2 id="思考" tabindex="-1"><a class="header-anchor" href="#思考"><span>思考</span></a></h2><p>从概念上看，Qwik 确实会大幅提升庞大应用程序的性能，能提供最快的首次渲染和交互性能。然而，作为一个新技术，尽管它有潜力成为未来广泛使用的框架之一，仍然需要时间和社区支持。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2>',35)),t("ol",null,[t("li",null,[t("a",c,[e[0]||(e[0]=i("A Brief History of Web Apps – Why Qwik is Innovative")),a(r)])]),t("li",null,[t("a",m,[e[1]||(e[1]=i("Qwik – The Post-Modern Framework")),a(r)])]),t("li",null,[t("a",g,[e[2]||(e[2]=i("Qwik.js框架是如何追求极致性能的?!")),a(r)])])])])}const w=n(d,[["render",h],["__file","005-qwik.html.vue"]]),k=JSON.parse('{"path":"/frontend/engineering/ssr/005-qwik.html","title":"Qwik","lang":"zh-CN","frontmatter":{"title":"Qwik","date":"2024-01-03T00:00:00.000Z","icon":"STARTUP","category":["工程化"],"tag":["frontend","SSR"],"description":"Web Apps 历史 在了解 Qwik 之前，有必要了解 Web 应用程序的历史。 第一代 第一代应用程序采用 MPA 技术，是在服务器上通过 PHP 等技术完成的。 服务器会渲染一系列包含 HTML 和 JavaScript 的文档，客户端使用 jQuery 在模板中添加交互。 这种方法的问题在于必须处理两种语言，一种在服务器端（如 PHP），另一...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/engineering/ssr/005-qwik.html"}],["meta",{"property":"og:title","content":"Qwik"}],["meta",{"property":"og:description","content":"Web Apps 历史 在了解 Qwik 之前，有必要了解 Web 应用程序的历史。 第一代 第一代应用程序采用 MPA 技术，是在服务器上通过 PHP 等技术完成的。 服务器会渲染一系列包含 HTML 和 JavaScript 的文档，客户端使用 jQuery 在模板中添加交互。 这种方法的问题在于必须处理两种语言，一种在服务器端（如 PHP），另一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd65c5da3920b_Client%20Rendering-min.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-06T15:43:46.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Qwik"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"frontend"}],["meta",{"property":"article:tag","content":"SSR"}],["meta",{"property":"article:published_time","content":"2024-01-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-06T15:43:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Qwik\\",\\"image\\":[\\"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd65c5da3920b_Client%20Rendering-min.jpg\\",\\"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd612ada3920c_Server%20Rendering-min%20(1\\",\\"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/63e3d6905bacd6233ba391e2_Hydration%20-%20Ready-min.jpg\\"],\\"datePublished\\":\\"2024-01-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-06T15:43:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 Web Apps 历史","slug":"web-apps-历史","link":"#web-apps-历史","children":[{"level":3,"title":"1.1 第一代","slug":"第一代","link":"#第一代","children":[]},{"level":3,"title":"1.2 第二代","slug":"第二代","link":"#第二代","children":[]},{"level":3,"title":"1.3 SSR","slug":"ssr","link":"#ssr","children":[]}]},{"level":2,"title":"2 Qwik 介绍","slug":"qwik-介绍","link":"#qwik-介绍","children":[{"level":3,"title":"2.1 Resumability","slug":"resumability","link":"#resumability","children":[]}]},{"level":2,"title":"3 思考","slug":"思考","link":"#思考","children":[]},{"level":2,"title":"4 参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1704616104000,"updatedTime":1730907826000,"contributors":[{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":2}]},"readingTime":{"minutes":3.77,"words":1130},"filePathRelative":"frontend/engineering/ssr/005-qwik.md","localizedDate":"2024年1月3日","excerpt":"","autoDesc":true}');export{w as comp,k as data};
