import{_ as t,o as e,c as n,e as o}from"./app-mY4m5HJr.js";const s={},a=o(`<h2 id="为什么会有-positon-定位" tabindex="-1"><a class="header-anchor" href="#为什么会有-positon-定位"><span>为什么会有 positon 定位</span></a></h2><p>HTML 中每个元素都是盒子，布局就像搭积木一样，从上往下挨个堆盒子，就能完成各式各样的页面，然而多实现几个页面就会发现：<strong>文档流中任意一个元素位置调整都会影响后面的元素</strong>。</p><p>这种布局方式称为<strong>标准流</strong>。它按从左到右、从上到下布局页面，互相不存在层叠现象。</p><figure><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/image-20230829181307056.png" alt="image-20230829181307056" tabindex="0" loading="lazy"><figcaption>image-20230829181307056</figcaption></figure><p>这种布局方式无法实现「元素层叠」效果，如果希望元素跳出文档流，应该如何做？</p><p>有一种脱离文档流的解决办法就是浮动，但浮动规则的局限性很大，它会向左上角或右上角靠过去，然而这两个方向并不是布局的全部。日益增长的网页复杂度，和落后的 CSS 布局方式之间的矛盾越来越大，让定位需求变得越来越复杂。</p><h2 id="基于定位的常见需求" tabindex="-1"><a class="header-anchor" href="#基于定位的常见需求"><span>基于定位的常见需求</span></a></h2><p>在开发中，常见的定位需求有如下几个：</p><ol><li>让元素可以相对于它自己的位置定位；</li><li>让元素可以在父元素（某个祖先级容器）范围内任意位置定位；</li><li>让元素可以在屏幕范围内任意位置定位；</li><li>让元素在满足某个条件时固定。</li></ol><h2 id="不同需求的解决方案" tabindex="-1"><a class="header-anchor" href="#不同需求的解决方案"><span>不同需求的解决方案</span></a></h2><h3 id="positon-relative" tabindex="-1"><a class="header-anchor" href="#positon-relative"><span><code>positon: relative</code></span></a></h3><p><strong>第一种需求：可以使用 <code>relative</code> 定位</strong>。</p><p>首先设置元素的 <code>position</code> 为 <code>relative</code>，让元素准备偏移，此时从视觉上来看它并没有发生任何变化。</p><p>接下来设置 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 来让元素偏移。</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.relative-box</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span> <span class="token comment">/* 元素上边界与它原本位置的上边界距离20px，其他类似 */</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li>定位参照对象是自己原来的位置；</li><li>相对定位的元素没有脱离文档流；</li><li>相对定位不会影响其他元素；</li><li>对非定位元素设置 <code>top</code> 等方向属性是没有效果的。</li></ol></div><h3 id="positon-absolute" tabindex="-1"><a class="header-anchor" href="#positon-absolute"><span><code>positon: absolute</code></span></a></h3><p><strong>第二种需求：使用 <code>absolute</code> 定位</strong>。</p><p>想要设置某个元素相对于某个祖先级元素容器定位，这就意味着元素不被限制在父容器内，因此浮动是肯定不行的（浮动只能在父容器里作威作福）。这就需要一种完全<strong>脱离文档流</strong>的定位方式：<code>positon: absolute</code>。</p><p>不再区分这个元素是块级元素还是行内元素，它的父容器会将它视为不存在，即：<strong>绝对定位元素不占据空间</strong>。</p><p>首先设置元素的 <code>position</code> 为 <code>absolute</code>，然后对它的祖先级元素容器设置标识 <code>position: relative</code>，这样就可以让它可以相对于被标识的元素定位，最后通过 <code>top</code> <code>right</code> <code>bottom</code> <code>left</code> 来让该元素在标识容器内偏移。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>绝对定位元素相对于最近的非 <code>static</code> 祖先元素定位（开发中一般标记为 <code>relative</code>）。当这样的祖先元素不存在时，则相对于视口定位。</p></div><h3 id="positon-fixed" tabindex="-1"><a class="header-anchor" href="#positon-fixed"><span><code>positon: fixed</code></span></a></h3><p><strong>第三种需求：使用 <code>fixed</code> 定位。</strong></p><p>这种定位方式会讲元素<strong>移出正常文档流</strong>，并且它是相对于**屏幕视口（文档的可视区域）**来指定元素位置。<strong>元素的位置在屏幕滚动时不会改变</strong>。</p><p>首先为元素设置 <code>position: fixed</code>，<strong>这时候必须为该元素设置宽高</strong>，最后通过 <code>top</code> <code>right</code> <code>bottom</code> <code>left</code> 来让该元素偏移。</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.fixed</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>
  <span class="token property">right</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">bottom</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当元素祖先的 <code>transform</code>、<code>perspective</code>、<code>filter</code> 或 <code>backdrop-filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p></div><h3 id="positon-sticky" tabindex="-1"><a class="header-anchor" href="#positon-sticky"><span><code>positon: sticky</code></span></a></h3><p><strong>第四种需求：使用 <code>sticky</code> 定位</strong>。</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。例如：</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><pre class="language-css"><code><span class="token selector">.sticky</span> <span class="token punctuation">{</span>
  <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>
  <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在屏幕视口滚动到元素 <code>top</code> 距离小于 <code>10px</code> 之前，元素为相对定位。之后，元素将固定在与顶部距离 <code>10px</code> 的位置，直到屏幕回滚到阈值以下。常用来做<strong>吸顶效果</strong>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><table><thead><tr><th></th><th>脱离标准流</th><th>定位元素</th><th>绝对定位元素</th><th>定位参考对象</th></tr></thead><tbody><tr><td><code>static</code></td><td>否</td><td>否</td><td>否</td><td>无</td></tr><tr><td><code>relative</code></td><td>否</td><td>是</td><td>否</td><td>元素原来的位置</td></tr><tr><td><code>absolute</code></td><td>是</td><td>是</td><td>是</td><td>最近的定位祖先元素</td></tr><tr><td><code>fixed</code></td><td>是</td><td>是</td><td>是</td><td>视口</td></tr></tbody></table>`,35),i=[a];function c(p,d){return e(),n("div",null,i)}const r=t(s,[["render",c],["__file","007-position.html.vue"]]),u=JSON.parse('{"path":"/frontend/basic/css/007-position.html","title":"定位","lang":"zh-CN","frontmatter":{"title":"定位","date":"2022-05-02T00:00:00.000Z","icon":"dingwei","category":["CSS"],"tag":["布局","frontend","basic-knowledge"],"description":"为什么会有 positon 定位 HTML 中每个元素都是盒子，布局就像搭积木一样，从上往下挨个堆盒子，就能完成各式各样的页面，然而多实现几个页面就会发现：文档流中任意一个元素位置调整都会影响后面的元素。 这种布局方式称为标准流。它按从左到右、从上到下布局页面，互相不存在层叠现象。 image-20230829181307056image-202308...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/basic/css/007-position.html"}],["meta",{"property":"og:title","content":"定位"}],["meta",{"property":"og:description","content":"为什么会有 positon 定位 HTML 中每个元素都是盒子，布局就像搭积木一样，从上往下挨个堆盒子，就能完成各式各样的页面，然而多实现几个页面就会发现：文档流中任意一个元素位置调整都会影响后面的元素。 这种布局方式称为标准流。它按从左到右、从上到下布局页面，互相不存在层叠现象。 image-20230829181307056image-202308..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/image-20230829181307056.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-24T06:39:15.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"定位"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"布局"}],["meta",{"property":"article:tag","content":"frontend"}],["meta",{"property":"article:tag","content":"basic-knowledge"}],["meta",{"property":"article:published_time","content":"2022-05-02T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-24T06:39:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"定位\\",\\"image\\":[\\"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/image-20230829181307056.png\\"],\\"datePublished\\":\\"2022-05-02T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-24T06:39:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 为什么会有 positon 定位","slug":"为什么会有-positon-定位","link":"#为什么会有-positon-定位","children":[]},{"level":2,"title":"2 基于定位的常见需求","slug":"基于定位的常见需求","link":"#基于定位的常见需求","children":[]},{"level":2,"title":"3 不同需求的解决方案","slug":"不同需求的解决方案","link":"#不同需求的解决方案","children":[{"level":3,"title":"3.1 positon: relative","slug":"positon-relative","link":"#positon-relative","children":[]},{"level":3,"title":"3.2 positon: absolute","slug":"positon-absolute","link":"#positon-absolute","children":[]},{"level":3,"title":"3.3 positon: fixed","slug":"positon-fixed","link":"#positon-fixed","children":[]},{"level":3,"title":"3.4 positon: sticky","slug":"positon-sticky","link":"#positon-sticky","children":[]}]},{"level":2,"title":"4 总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1693306986000,"updatedTime":1703399955000,"contributors":[{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":1},{"name":"wangziwenbj01","email":"wangziwenbj01@kanyun.com","commits":1}]},"readingTime":{"minutes":3.74,"words":1123},"filePathRelative":"frontend/basic/css/007-position.md","localizedDate":"2022年5月2日","excerpt":"","autoDesc":true}');export{r as comp,u as data};
