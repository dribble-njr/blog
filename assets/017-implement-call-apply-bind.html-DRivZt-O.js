import{_ as t,c as p,a,d as s,b as o,w as l,e as i,r as c,o as r}from"./app-azxGt0eK.js";const d={};function u(k,n){const e=c("RouteLink");return r(),p("div",null,[a("p",null,[n[1]||(n[1]=a("code",null,"call()",-1)),n[2]||(n[2]=s("、")),n[3]||(n[3]=a("code",null,"apply()",-1)),n[4]||(n[4]=s(" 和 ")),n[5]||(n[5]=a("code",null,"bind()",-1)),n[6]||(n[6]=s(" 三者都可以改变 JavaScript 中的 this 指向，关于三者的区别在 ")),o(e,{to:"/frontend/basic/javascript/016-this.html"},{default:l(()=>n[0]||(n[0]=[s("this 指向")])),_:1}),n[7]||(n[7]=s("中有详细记录。"))]),n[8]||(n[8]=i(`<p>这三个函数实际上是由 C++ 实现的，这里只考虑功能上的实现，不会考虑太多边界情况。</p><h2 id="call" tabindex="-1"><a class="header-anchor" href="#call"><span><code>call()</code></span></a></h2><p><code>call()</code> 接受一个 <code>this</code> 指向，其后跟参数列表。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将 thisArg 转成对象类型（防止传入非对象类型）</span>
  <span class="token comment">// 传入 null 或 undefined 则为全局对象</span>
  thisArg <span class="token operator">=</span> thisArg <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> thisArg <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span> <span class="token operator">:</span> window

  <span class="token comment">// foo.myCall();</span>
  <span class="token comment">// foo 是函数，本质上也是一个对象，即隐式绑定：对象（foo）调用函数（myCall）</span>
  <span class="token comment">// 那么函数 myCall 中的 this 指向 foo 对象（函数）</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// foo</span>

  <span class="token comment">// 需要将 fn 的指向改为 thisArg</span>
  <span class="token comment">// 那么可以继续利用 this 的隐式绑定规则</span>
  thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn
  <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn

  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="apply" tabindex="-1"><a class="header-anchor" href="#apply"><span><code>apply()</code></span></a></h2><p><code>apply()</code> 与 <code>call()</code> 的区别在于传入的是参数数组，参照上面流程，可以很容易的写出：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理 thisArg</span>
  thisArg <span class="token operator">=</span> thisArg <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> thisArg <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span> <span class="token operator">:</span> window

  <span class="token comment">// 获取待执行函数</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token comment">// 执行</span>
  thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn
  <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn

  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bind" tabindex="-1"><a class="header-anchor" href="#bind"><span><code>bind()</code></span></a></h2><p><code>bind()</code> 函数稍有不同，它返回一个改变了 <code>this</code> 的函数：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">thisArg<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 处理 thisArg</span>
  thisArg <span class="token operator">=</span> thisArg <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> thisArg <span class="token operator">!==</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token function">Object</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">)</span> <span class="token operator">:</span> window

  <span class="token comment">// 获取待执行函数</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">_bind</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>newArgs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 收集参数</span>
    <span class="token keyword">const</span> finalArgs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>newArgs<span class="token punctuation">]</span>

    <span class="token comment">// 执行</span>
    thisArg<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn
    <span class="token keyword">const</span> res <span class="token operator">=</span> thisArg<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>finalArgs<span class="token punctuation">)</span>
    <span class="token keyword">delete</span> thisArg<span class="token punctuation">.</span>fn

    <span class="token keyword">return</span> res
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>手写 <code>call</code>、<code>apply</code>、<code>bind</code> 的步骤大致相同，只是 <code>bind</code> 多了一个收集参数的过程：</p><ol><li>处理 thisArg;</li><li>获取待执行函数；</li><li>执行函数（<code>bind()</code> 还有一个收集参数的过程）。</li></ol><p>无论是在获取函数还是执行函数（改变 <code>this</code>）的过程中，都是利用了隐式绑定改变 <code>this</code> 指向的规则。</p>`,14))])}const v=t(d,[["render",u],["__file","017-implement-call-apply-bind.html.vue"]]),b=JSON.parse('{"path":"/frontend/basic/javascript/017-implement-call-apply-bind.html","title":"手写 call、apply、bind","lang":"zh-CN","frontmatter":{"title":"手写 call、apply、bind","date":"2022-04-27T00:00:00.000Z","icon":"code","category":["JavaScript"],"tag":["this","手写代码"],"description":"call()、apply() 和 bind() 三者都可以改变 JavaScript 中的 this 指向，关于三者的区别在 中有详细记录。 这三个函数实际上是由 C++ 实现的，这里只考虑功能上的实现，不会考虑太多边界情况。 call() call() 接受一个 this 指向，其后跟参数列表。 apply() apply() 与 call() 的区...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/basic/javascript/017-implement-call-apply-bind.html"}],["meta",{"property":"og:title","content":"手写 call、apply、bind"}],["meta",{"property":"og:description","content":"call()、apply() 和 bind() 三者都可以改变 JavaScript 中的 this 指向，关于三者的区别在 中有详细记录。 这三个函数实际上是由 C++ 实现的，这里只考虑功能上的实现，不会考虑太多边界情况。 call() call() 接受一个 this 指向，其后跟参数列表。 apply() apply() 与 call() 的区..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-06T15:43:46.000Z"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"this"}],["meta",{"property":"article:tag","content":"手写代码"}],["meta",{"property":"article:published_time","content":"2022-04-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-06T15:43:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"手写 call、apply、bind\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-06T15:43:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 call()","slug":"call","link":"#call","children":[]},{"level":2,"title":"2 apply()","slug":"apply","link":"#apply","children":[]},{"level":2,"title":"3 bind()","slug":"bind","link":"#bind","children":[]},{"level":2,"title":"4 总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1723019391000,"updatedTime":1730907826000,"contributors":[{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":2}]},"readingTime":{"minutes":1.6,"words":479},"filePathRelative":"frontend/basic/javascript/017-implement-call-apply-bind.md","localizedDate":"2022年4月27日","excerpt":"","autoDesc":true}');export{v as comp,b as data};
