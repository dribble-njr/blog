import{_ as o,c as r,e as i,a,d as s,b as t,r as p,o as l}from"./app-x8ymDRL-.js";const c={},d={href:"https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},u={href:"https://blog.fundebug.com/2019/07/16/how-does-v8-work/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://v8.dev/blog/scanner",target:"_blank",rel:"noopener noreferrer"},g={href:"https://v8.dev/blog/preparser",target:"_blank",rel:"noopener noreferrer"},b={href:"https://v8.dev/blog/ignition-interpreter",target:"_blank",rel:"noopener noreferrer"},k={href:"https://mp.weixin.qq.com/s/t__Jqzg1rbTlsCHXKMwh6A",target:"_blank",rel:"noopener noreferrer"};function v(h,n){const e=p("ExternalLinkIcon");return l(),r("div",null,[n[6]||(n[6]=i(`<p>在 JavaScript 引擎中，V8 无疑是最流行的，Chrome 与 Node.js 都使用了 V8 引擎。</p><p>V8 由很多子模块构成，有几个核心模块：</p><ul><li>Parser：解析器，负责将 JavaScript 代码解析成抽象语法树（Abstract Syntax Tree, AST）；</li><li>Ignition：解释器（interpreter），负责将 AST 转换为字节码（Bytecode）并执行；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；</li><li>TurboFan：编译器（compiler），利用 Ignition 所收集的信息，将字节码转换为优化的机器码；</li><li>Orinoco：垃圾回收（garbage collector），负责将程序不再需要的内存空间回收。</li></ul><p>下面这张图是 V8 现有的工作流程，非常重要，在后面阅读的时候可以翻上来看看。</p><figure><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/v8-work-flow.webp" alt="v8-work-flow" tabindex="0" loading="lazy"><figcaption>v8-work-flow</figcaption></figure><h2 id="parser" tabindex="-1"><a class="header-anchor" href="#parser"><span>Parser</span></a></h2><p>为了让 V8 能够理解 JavaScript 代码，必须先将源码通过 <strong>Parser</strong> 解析成抽象语法树——代表程序结构的一系列对象。然后抽象语法树会被 <strong>Ignition</strong> 编译成字节码。这两个阶段是 V8 引擎性能的关键。</p><p>下图是 Parser 的工作流程：</p><img src="https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/parser.svg" style="background-color:#fff;"><p>整个流程分为两个阶段：词法分析和语法分析。</p><ul><li><strong>词法分析</strong>：scanner 从我们编写的 JavaScript 代码中生成一系列的 tokens。而 tokens 是由一个或多个具有单一语义的字符组成的块：字符串、标识符、运算符 <code>++</code> 等。</li><li><strong>语法分析</strong>：语法分析的输入就是词法分析的输出（即 tokens），输出是 AST 抽象语法树。当程序出现语法错误的时候，V8 会在语法分析阶段抛出异常。</li></ul><p>V8 为了提升 scanner 性能，又做了 <strong>延迟解析</strong>（lazy parsing）的优化，一些不会用到函数并不会被马上编译，他们会被 PreParser 处理，当以后调用一个 <code>preparsed</code> 函数时，它会根据需要进行完全解析和编译。</p><h2 id="ignition" tabindex="-1"><a class="header-anchor" href="#ignition"><span>Ignition</span></a></h2><p>当 Parser 将代码解析成 AST 输入给 Ignition，Ignition 会将 AST 转换为字节码，分三种情况：</p><ul><li>函数只声明而不调用，则 Ignition 不会做任何操作；</li><li>如果函数只调用一次，则 Ignition 会解释字节码并执行。下面来看看例子；</li><li>如果函数调用多次，则 Ignition 会收集 TurboFan 优化所需的信息（比如函数参数的类型信息等）。</li></ul><p>下面来看看例子。</p><ol><li><p>只是声明函数 <code>add</code>，但是没有调用，则 Ignition 不会做任何转换。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>声明后第一次调用 <code>add</code> 函数，Ignition 会把它编译成字节码执行。到这个时候，JavaScript 代码就已经执行完成了。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>但是如果发现有<strong>热点函数</strong>（即一个函数被多次调用），Ignition 就会收集 <code>add</code> 函数的各种参数类型，为 TurboFan 的优化提供支持。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 调用多次，标记成热点函数，收集各种信息</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="turbofan" tabindex="-1"><a class="header-anchor" href="#turbofan"><span>TurboFan</span></a></h2><p>TurboFan 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码。如果一个函数被多次调用，就会被标记为<strong>热点函数</strong>，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>V8 的 <code>%OptimizeFunctionOnNextCall</code> 可以直接指定优化哪个函数，它根据上次调用的参数反馈优化 <code>add</code> 函数，很明显这次的反馈是整型数，所以 TurboFan 会根据参数是整型数进行优化直接生成机器码，下次函数调用直接调用优化好的机器码。</p><p>但是，机器码实际上也会被还原为字节码，这是因为如果后续执行函数的过程中，类型发生了变化（比如 <code>add</code> 函数原来执行的是 <code>number</code> 类型，后来执行变成了 <code>string</code> 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码。这个就是最上面那个图还有个 <code>Deoptimization</code> 的原因。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>到此，V8 引擎的工作流程就已经完成了，但是还没有细究里面的执行细节，只是大概地了解了工作流程，等以后能完全看懂官方文章了再回来更新。</p></blockquote><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h2>`,25)),a("ol",null,[a("li",null,[a("a",d,[n[0]||(n[0]=s("JavaScript 引擎 - 维基百科")),t(e)])]),a("li",null,[a("a",u,[n[1]||(n[1]=s("JavaScript 深入浅出第 4 课：V8 引擎是如何工作的？")),t(e)])]),a("li",null,[a("a",m,[n[2]||(n[2]=s("Blazingly fast parsing, part 1: optimizing the scanner")),t(e)])]),a("li",null,[a("a",g,[n[3]||(n[3]=s("Blazingly fast parsing, part 2: lazy parsing · V8")),t(e)])]),a("li",null,[a("a",b,[n[4]||(n[4]=s("Firing up the Ignition interpreter · V8")),t(e)])]),a("li",null,[a("a",k,[n[5]||(n[5]=s("JavaScript 引擎 V8 执行流程概述")),t(e)])])])])}const y=o(c,[["render",v],["__file","02-V8.html.vue"]]),w=JSON.parse('{"path":"/frontend/browser/02-V8.html","title":"V8 引擎","lang":"zh-CN","frontmatter":{"title":"V8 引擎","date":"2022-01-13T00:00:00.000Z","icon":"principle","category":["browser"],"tag":["V8 引擎"],"description":"在 JavaScript 引擎中，V8 无疑是最流行的，Chrome 与 Node.js 都使用了 V8 引擎。 V8 由很多子模块构成，有几个核心模块： Parser：解析器，负责将 JavaScript 代码解析成抽象语法树（Abstract Syntax Tree, AST）； Ignition：解释器（interpreter），负责将 AST ...","head":[["meta",{"property":"og:url","content":"https://dribble-njr.github.io/blog/blog/frontend/browser/02-V8.html"}],["meta",{"property":"og:title","content":"V8 引擎"}],["meta",{"property":"og:description","content":"在 JavaScript 引擎中，V8 无疑是最流行的，Chrome 与 Node.js 都使用了 V8 引擎。 V8 由很多子模块构成，有几个核心模块： Parser：解析器，负责将 JavaScript 代码解析成抽象语法树（Abstract Syntax Tree, AST）； Ignition：解释器（interpreter），负责将 AST ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/v8-work-flow.webp"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-06T15:43:46.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"V8 引擎"}],["meta",{"property":"article:author","content":"njr"}],["meta",{"property":"article:tag","content":"V8 引擎"}],["meta",{"property":"article:published_time","content":"2022-01-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-06T15:43:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"V8 引擎\\",\\"image\\":[\\"https://raw.githubusercontent.com/dribble-njr/typora-njr/master/img/v8-work-flow.webp\\"],\\"datePublished\\":\\"2022-01-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-06T15:43:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"njr\\",\\"url\\":\\"https://github.com/dribble-njr/blog\\",\\"email\\":\\"wzw15292257101@163.com\\"}]}"]]},"headers":[{"level":2,"title":"1 Parser","slug":"parser","link":"#parser","children":[]},{"level":2,"title":"2 Ignition","slug":"ignition","link":"#ignition","children":[]},{"level":2,"title":"3 TurboFan","slug":"turbofan","link":"#turbofan","children":[]},{"level":2,"title":"4 参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"git":{"createdTime":1713159120000,"updatedTime":1730907826000,"contributors":[{"name":"dribble-njr","email":"wzw15292257101@163.com","commits":2}]},"readingTime":{"minutes":4.02,"words":1206},"filePathRelative":"frontend/browser/02-V8.md","localizedDate":"2022年1月13日","excerpt":"","autoDesc":true}');export{y as comp,w as data};
